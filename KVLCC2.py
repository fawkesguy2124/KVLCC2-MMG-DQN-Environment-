# -*- coding: utf-8 -*-
"""KVLCC2.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jma1rLeeVO8UXEV5LHmKGnMxrkszzIWk
"""

import math
from math import sin,cos
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

"""L7 model Particulars for KVLCC2 Container"""

B= 1.27
Lpp = 7
d = 0.46
vd = 3.27
xG = 0.25
cb = 0.81
Dp = 0.216 #Diamater of Propeller
Hr = 0.345 #Rudder span
Ar = 0.0539  #Profile area of movable part of mariner rudder
phro = 1025
eta = Dp/Hr
m = vd*phro  #mass = volume displaced *phro sea water
rad_yg = 0.25*Lpp
Izg = m*(rad_yg**2)


U0 = 1.179  # Initial Forward Velocity for KVLCC2 - L7 model


mx_p = 0.022
my_p = 0.223
Jz_p = 0.011

mx = (mx_p)* (0.5)* (phro) * (Lpp**2)*d
my = (my_p) * (0.5)* (phro) * (Lpp**2)*d
Jz = (Jz_p) * (0.5)* (phro) * (Lpp**4)*d

"""Hydrodynamic force coefficients used in simulation

"""

R0_p = 0.022

Xvv_p = -0.040
XvR_p = 0.002
XRR_p = 0.011
Xvvvv_p = 0.771

Yv_p = -0.315
YR_p = 0.083
Yvvv_p = -1.607
YvvR_p = 0.379
YvRR = -0.391
YRRR_p = 0.008

Nv_p = -0.137
NR_p = -0.049
Nvvv_p = -0.030
NvvR_p = -0.294
NvRR_p = 0.055
NRRR_p = -0.013

def KVLCC2_ode(t,v,delta_c):

  u = v[0]
  vm =v[1]
  r = v[2]
  x = v[3]
  y = v[4]
  psi = v[5]
  delta = v[6]

  U =(u**2 + vm**2)**(0.5)

 #Hydrodynamic forces acting on ship hull


  Xh_p = (-R0_p + Xvv_p*((vm/U**2) + XvR_p*(vm/U)*(r*Lpp/U) + XRR_p*((r*Lpp/U)**2) + Xvvvv_p*((vm/U)**4)))

  Yh_p = (Yv_p*(vm/U) + YR_p*(r*Lpp/U) + Yvvv_p*((vm/U)**3) + YvvR_p*((vm/U)**2) *(r*Lpp/U) + YvRR*((vm/U))*((r*Lpp/U)**2) + (YRRR_p)*((r*Lpp/U)**3))

  Nh_p =  (Nv_p *(vm/U) + NR_p*(r*Lpp/U) + Nvvv_p * ((vm/U)**3) + NvvR_p * ((vm/U)**2)*(r*Lpp/U) + NvRR_p *((vm/U)) *((r*Lpp/U)**2) + NRRR_p*((r*Lpp/U)**3))


  Xh = Xh_p(u,vm,r)*(0.5)*(phro)*(Lpp)*d*(U**2)

  Yh = Yh_p(u,vm,r)*(0.5)*(phro)*(Lpp)*d*(U**2)

  Nh = Nh_p(u,vm,r)*(0.5)*(phro)*(Lpp**2)*d*(U**2)

 # Hydrodynamic Forces due to Propeller

  tp = 0.220 # Thrust deduction factor
  phro = 1025 # Density of salt water
  npr = 11.85   #11.8 # propeler revolution (14.48, 17.95, and 24.87)
  Dp = 0.216 # Propeller diameter
  k0 = 0.2931 # Coefficients representing KT
  k1 = -0.2753
  k2 = -0.1385

  xP = -0.48            #xP = -0.5*Lpp

  C1 = 2.0 #Experimental constants representing wake characteristic in maneuvering
  wp0 = 0.40 # Wake coefficient at propeller position in straight moving


  C2 = 1.6 if beta_p >0 else 1.1

  beta = math.atan(-vm/u)  #drift angle

  beta_p = beta - xP*(r*Lpp/U)    #beta(u,vm) - xP*(r*U(u,vm)/Lpp)


  wp = 1 - ((1-wp0)* (1+(1- ((math.e)**(-C1*abs(beta_p))))*(C2-1)))


  Jp = (u*(1-wp(u,vm,r))/(npr*Dp)) # Propeller advanced ratio

  KT = k2*(Jp**2) + k1*Jp + k0   #Propeller thrust open water characteristic


  T  = phro * (npr**2) * (Dp**4) * KT # Propeller thrust


  Xp = (1-tp) * T   # Surge force due to propeller

  #Rudder Steering Rate


  T_rud= 0.1 * Lpp/U0

  #delta_c = +35*(math.pi)/180
  delta_d_max = 11.899*(math.pi)/180    #11.899


  delta_d = (delta_c - delta) / T_rud

  if np.abs(delta_d) > delta_d_max:
    delta_d = np.sign(delta_d) * delta_d_max

  #Hydrodynamic forces by steering

  tr = 0.387 #Steering resistance deduction factor
  e = 1.09 #Ratio of wake fraction at propeller and rudder positions
  k = 0.50 #An experimental constant for expressing ur
  l_r = -0.710
  falpha = 2.747



  beta_r = beta- l_r*(r*Lpp/U)

  gamma_r = 0.640 if beta_r >0 else 0.395

  aH = 0.312
  xR =-0.5 *Lpp
  xH = -0.464 *Lpp



  vr = U *gamma_r* beta_r

  ur = e * u * (1 - wp) * ((eta* ((1 + k * (((( 8*KT)/((math.pi)*Jp**2 )) + 1)**0.5 - 1))**2)) + (1 - eta))**0.5

  Ur = (ur**2 + vr**2)**(0.5)



  alpha_r =delta -math.atan(vr/ur)

  sin_alpha_r  = sin(alpha_r)

  Fn = 0.5 *phro *Ar * (Ur**2) *falpha* sin_alpha_r



  Xr = -(1-tr)* Fn* sin(delta)

  Yr = -(1+ aH)* Fn * cos(delta)

  Nr = -(xR + aH*xH) *Fn *cos(delta)

  #Total Forces and yaw moment acting on Ship


  X =  Xh + Xr + Xp

  Y = Yh + Yr

  Nm = Nh + Nr

  #Solving the differential Equations(For Starboard)



  import numpy as np

  Mat1 = np.array([ [m +mx, 0, 0, 0, 0, 0, 0],                     #Coefficients of u_dot,v_dot,r_dot,u,v,r,delta_dot
                    [0, m+my, xG*m, 0, 0, 0, 0],
                    [0, xG*m, Izg +(xG**2)*m + Jz, 0, 0, 0, 0],    # [u_dot,v_dot, r_dot,u, v , r, delta_dot] = Mat_inverse *[u,v,r,x,y,psi,delta]
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 1]])



  Mat_inverse1 = np.linalg.inv(Mat1)



  N1 = np.array([ [X+(xG*m*r**2)+(m+my)*vm*r],
                      [Y-(m+mx)*u*r],
                      [Nm -xG*m*u*r],
                      [cos(psi)*u-sin(psi)*vm],          # from here I use the rotation matrix to transform them to the Global coordiinate system
                      [sin(psi)*u+cos(psi)*vm],
                      [r],
                      [delta_d]])


  return np.matmul(Mat_inverse1,N1)